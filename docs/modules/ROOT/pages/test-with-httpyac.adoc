ifdef::env-github[]
:imagesdir: ../assets/images
endif::[]
:xrefstyle: short

= Test With HttpYac & Chai

HttpYac is a simple NodeJs testing client. HttpYac test files use the `.http` 
extension and it supports two testing modes:

* with the Visual Studio Code extension
* with the HttpYac CLI

The Visual Studio Code extension is used to quickly test inside VSCode, while the 
HttpYac CLI is used in the CI/CD pipeline.

== Test With the HttpYac VSCode Extension

. Install the 
https://marketplace.visualstudio.com/items?itemName=anweber.vscode-httpyac[HttpYac VSCode extension].

. Let's start with a basic example taken from
the https://github.com/integonch/mi-template[mi-template] repository:
Create the three files shown in <<test-folder-structure>>.
+
.Test Folder Structure
[source#test-folder-structure, console]
----
src/test
└── httpyac
    ├── .env <1>
    ├── health.http <2>
    └── local.env <3>
----
<1> The global environment file, see <<global-env>>
<2> The test file, see <<health>>
<3> The local environment file, see <<local-env>>
+
.The health.http File
[source#health,javascript]
----
@host=https://{{MI_HOST}}:8243

/*
Simple health test without any dependencies
*/
GET /health
{{
    test.status(200);
    test.hasResponseBody();
}}
----
+
.The .env File: 
[source#global-env, env]
----
request_rejectUnauthorized=false <1>
----
<1> Trusts the self-signed WSO2 certificate so that we can directly test with https.
+
.The local.env File
[source#local-env, env]
----
MI_HOST=localhost
----

. Click on _env_ at the top of the `health.http` file and select the local environment
as shown in <<img-httpyac-vscode>>.
+
.The HttpYac VSCode Extension in Action
[#img-httpyac-vscode]
image::httpyac-vscode.png[HttpYac VSCode Extension in Action]

. Start the Micro Integrator. E.g for the
https://github.com/integonch/mi-template[mi-template] repo, start
the Micro Integrator with the commands shown in <<start-mi>>.
+
.Start the Micro Integrator
[source#start-mi, bash]
----
mvn clean package
docker compose up
----

. Click on _send_ as shown in <<img-httpyac-vscode>> to run the test and a new
window on the rigth side opens with the received JSON answer. You can
click on _TestResults_ or _content_type_ to get a detailed view of the
sent request and received response including headers. This is especially useful
for investigating errors.

== Test With the HttpYac Command Line Interface (CLI)

The HttpYac CLI is a Node.js command line application and you can run your
tests with `httpyac <test.http>`. See the official
https://httpyac.github.io/guide/installation_cli.html[docs] for all supported
options.

Since it is a Node.js application, there are multiple ways to run it:

* Install and run the CLI locally
* Containerise the CLI and run it with Docker
* Containerise the CLI and run it with Docker Compose
* Containerise the CLI and run it with Kubernetes

[#run-locally]
=== Run the HttpYac CLI Locally

. Install the HttpYac CLI with `npm install httpyac`.
. Start the Micro Integrator.
. Run the HttpYac CLI with `npx httpyac <test.http> -e local`.

[#run-with-docker]
=== Run the HttpYac CLI With Docker

. Firstly, we use the Dockerfile shown in <<dockerfile-httpyac>> to containerise
the HttpYac CLI.
+
.Dockerfile for the HttpYac CLI
[source#dockerfile-httpyac, dockerfile]
----
FROM node:16-alpine # <1>
USER node
ENV NODE_ENV=production
WORKDIR /app
RUN npm install httpyac@5.8.2 chai@4.3.7 # <2>
ENTRYPOINT [ "npx", "httpyac" ]
----
<1> We use the official Node.js alpine Docker image, which is small and supports
multiple architectures so that it can be used on aarch64 (e.g., Silicon Macs) 
as well.
<2> We also install the chai assertion library, for even more powerful tests.

. Then we start the Micro Integrator again, build the Docker image and run the
tests with the commands shown in <<run-httpyac-docker>>.

.Run the HttpYac CLI With Docker
[source#run-httpyac-docker, console]
----
# start the Micro Integrator, e.g. with docker or docker compose
docker build -t httpyac:5.8.2 .
docker run -it --rm -v <path to .http folder>:/app/httpyac httpyac:5.8.2 \
    "httpyac" -a -o short -e docker
----

IMPORTANT: Since _localhost_ points to the loopback address of Docker, we need 
to use `MI_HOST=host.docker.internal`. For this, we create another environment
file, called `docker.env` and use it with the `-e docker` environment file option
as shown in <<run-httpyac-docker>>.

=== Run the HttpYac CLI With Docker Compose

In <<run-with-docker>> and <<run-locally>> we manually started the Micro
Integrator first, then waited until it was ready and then ran the HttpYac CLI to
start the tests.
This is not very convenient, so let's use Docker Compose to automate this 
dependent service startup by combining the `healthcheck` and `depends_on` options
as shown in <<docker-compose-httpyac-mi>>.

.Docker Compose File for the HttpYac CLI and the Micro Integrator
[source#docker-compose-httpyac-mi, yaml]
----
version: '3.3'
services:
    mi-template:
        image: "docker.io/wso2/wso2mi:4.1.0-multiarch"
        ports:
            - "8280:8280"
            - "8243:8243"
            - "9191:9191"
            - "9154:9154"
        healthcheck: # <1>
          test        : [ "CMD", "curl", "-f", "http://localhost:9191/healthz" ]
          interval    : 1s
          timeout     : 2s
          retries     : 3
          start_period: 5s

        volumes:
            - ./target/capp:/home/wso2carbon/wso2mi-4.1.0/repository/deployment/server/carbonapps
            - ./mi-home/conf/deployment.toml:/home/wso2carbon/wso2mi-4.1.0/conf/deployment.toml

    test:
      build:
        context: .
        dockerfile: docker/test/Dockerfile
      volumes:
        - ./src/test/httpyac:/app/httpyac
      command: ["httpyac", "-a", "-o", "short", "-e", "docker-compose" ] # <2>
      depends_on: # <3>
        mi-template:
          condition: service_healthy # <3>
----
<1> We use the `healthcheck` option to query the internal `healthz` endpoint of
the Micro Integrator to check if it is ready.
<2> Here again we use a custom `docker-compose.env` environment file because the
`MI_HOST` is `mi-template` and not `localhost` inside the docker compose network.
<3> We use the `depends_on` option with the `service_healthy` condition to start
the HttpYac CLI only after the Micro Integrator is ready.

As a result, we can start the Micro Integrator and the HttpYac CLI with a single
`docker compose up` command.

== HttpYac Basics

The three health check tests shown in <<httpyac-basics>> are all valid HttpYac
tests and show the versatility of the HttpYac test syntax. It can not only be
used as a simple `curl` replacement, but can also be extended with a fully fledged
test framework such as `chai` or any other npm package (e.g. an XPath library).
See the official 
https://httpyac.github.io/guide/request.html[HttpYac documentation] for more
information about _query parameters_ and different authentication methods such as
_Basic Auth_ and _OAuth2_.

.HttpYac Basics
[source#httpyac-basics, javascript]
----
@host=https://{{MI_HOST}}:8243 // <1>

/*
Simple health test without any dependencies // <2>
*/
GET /health
{{
    test.status(200);
    test.hasResponseBody();
}}

### // <3>

/*
Health test with header checking without any dependencies
*/
GET /health
{{
    test.status(200);
    test.hasResponseBody();
    test.header("Content-Type", "application/json; charset=UTF-8");
}}

###

/*
Health test with chai dependency for more complex tests. This test does not 
work inside the httpYac VSCode extension unless you have chai installed with
npm. In the Docker image, however, chai is already installed and the test
will work.
*/
GET /health
{{
    // standard test without dependencies
    test.status(200);
    test.hasResponseBody();
    test.header("Content-Type", "application/json; charset=UTF-8");

    // additional javascript specific test using the specialized chai library
    const expect = require('chai').expect;
    test('Status should be "UP"', () => {
        expect(response.parsedBody.Status).to.equal('UP');
    });
}}
----
<1> We use the `@host` directive to set the host for all tests in the file.
In addition, we inject the `MI_HOST` environment variable with the `{{MI_HOST}}`
syntax.
<2> Comment lines are used to describe the test. This output is shown in the
console when the test is executed.
<3> The `\###` line is used to separate the tests.

=== Organize Environment Files

As a convention, the HttpYac Vscode extension looks for environment files in a
environment folder called `env`. Therefore, it makes sense to put your different
environment files in this folder as shown in <<env-folder>>.

.Folder Structure for Environment Files
[source#env-folder, console]
----
src/test/httpyac/
├── env // <1>
│   ├── docker-compose.env
│   ├── docker.env
│   └── local.env
├── health.http <2>
└── second-test.http <2>
----
<1> The `env` folder contains the environment files and is automatically 
recognized by the HttpYac Vscode extension.
<2> The `health.http` and `second-test.http` files are HttpYac test files.